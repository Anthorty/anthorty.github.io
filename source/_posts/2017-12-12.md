---
title: 由一次map引发的思考
date: 2017-12-12 16:46:11
tags:
- Python
- 笔记
description: "map是一个非常方便的高阶函数，但也有一些不易发现的方法。"
---
## 从map的运算方式开始

首先定义一个简单函数和一个列表
```
def foo(x):
	return x * x

L = [1,2,3,4]
```
然后使用map函数，迭代计算出结果
```
In [11]: list(map(foo,L))
Out[11]: [1, 4, 9, 16]
```
如果这时候加上x，会怎么样呢？说干就干
```
In [12]: x = 3

In [13]: list(map(foo(x),L))
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-13-d15e71ee2031> in <module>()
----> 1 list(map(foo(x),L))

TypeError: 'int' object is not callable
```
## 给匿名函数传值
直接报错了，那如果返回的是另外一个函数呢？用匿名函数试一下
```
In [14]: def foo1(x):
    ...:     return lambda x: x * x
    ...:

In [15]: list(map(foo1(x),L))
Out[15]: [1, 4, 9, 16]
```
此时能计算出正确的值，但是`foo1(x)`中的`x`参数此时对map对象没有影响了，也就是说x的值并没有传入到匿名函数中。
不带x参数的时候，运行结果是
```
In [18]: list(map(foo1,L))
Out[18]:
[<function __main__.foo1.<locals>.<lambda>>,
 <function __main__.foo1.<locals>.<lambda>>,
 <function __main__.foo1.<locals>.<lambda>>,
 <function __main__.foo1.<locals>.<lambda>>]
```
相比之下，使用表达式方式才是使用匿名函数的正确姿势
```
In [16]: a = lambda y:y * y

In [17]: list(map(a,L))
Out[17]: [1, 4, 9, 16]
```
而这种方式也是匿名函数的初衷。