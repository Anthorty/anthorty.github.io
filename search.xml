<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[由一次map引发的思考]]></title>
    <url>%2F2017%2F12%2F12%2F2017-12-12%2F</url>
    <content type="text"><![CDATA[从匿名函数开始首先定义一个简单函数和一个列表1234def foo(x): return x * xL = [1,2,3,4] 然后使用map函数，迭代计算出结果12In [11]: list(map(foo,L))Out[11]: [1, 4, 9, 16] 如果这时候加上x，会怎么样呢？说干就干123456789In [12]: x = 3In [13]: list(map(foo(x),L))---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-13-d15e71ee2031&gt; in &lt;module&gt;()----&gt; 1 list(map(foo(x),L))TypeError: &apos;int&apos; object is not callable 直接报错了，那如果返回的是另外一个函数呢？用匿名函数试一下123456In [14]: def foo1(x): ...: return lambda x: x * x ...:In [15]: list(map(foo1(x),L))Out[15]: [1, 4, 9, 16] 此时能计算出正确的值，但是foo1(x)中的x参数此时对map对象没有影响了，也就是说x的值并没有传入到匿名函数中。不带x参数的时候，运行结果是123456In [18]: list(map(foo1,L))Out[18]:[&lt;function __main__.foo1.&lt;locals&gt;.&lt;lambda&gt;&gt;, &lt;function __main__.foo1.&lt;locals&gt;.&lt;lambda&gt;&gt;, &lt;function __main__.foo1.&lt;locals&gt;.&lt;lambda&gt;&gt;, &lt;function __main__.foo1.&lt;locals&gt;.&lt;lambda&gt;&gt;] 相比之下，使用表达式方式才是使用匿名函数的正确姿势1234In [16]: a = lambda y:y * yIn [17]: list(map(a,L))Out[17]: [1, 4, 9, 16] 而这种方式也是匿名函数的初衷。]]></content>
      <tags>
        <tag>Python</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多进程和多线程]]></title>
    <url>%2F2017%2F05%2F23%2F%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多进程 在Linux和Unix环境下，系统提供了os.fork()接口，可以直接调用。在Windows环境下，系统没有提供fork(),可以使用multiprocess库来打到多进程和多线程的目的。]]></content>
      <tags>
        <tag>Python3</tag>
        <tag>multiprocess</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 IO读写]]></title>
    <url>%2F2017%2F05%2F16%2Fpython3%2F</url>
    <content type="text"><![CDATA[IO读写（内存读写） 内存读写不同于文件读写，内存读取后，内存指针会偏移。 1234567891011121314151617181920# ExampleIn [3]: from io import StringIO,BytesIO # 使用前需要先导入模块In [4]: a = StringIO('Hello,World!') #创建一个字符串对象In [5]: a.readline() #读取内存保存的字符串Out[5]: 'Hello,World!'In [6]: a.tell() #现在的内存地址Out[6]: 12In [7]: a.readline() #返回空字符串，因为内存地址移动了Out[7]: ''In [8]: a.seek(0) #seek函数可以设置内存地址Out[8]: 0In [10]: a.readline() #设置为初始值，可以读出字符串Out[10]: 'Hello,World!']]></content>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOP（面向对象编程）]]></title>
    <url>%2F2017%2F05%2F15%2FOOP(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B)%2F</url>
    <content type="text"><![CDATA[面向对象编程是一种程序设计的思想，或者叫做一种程序设计模式。 核心就是一切皆对象。 什么是对象？前面说了，一切皆对象。所有能称得上”东西“的实体，都可以称作对象。在 Python 中每一种数据类型，都是对象。对象是程序的基本单元，换句话说，程序其实是对象的集合。对象，能接收消息，也能够处理这些消息，当然也能发出消息。 类和实例Python 中除了 int、float、str，bool等基本数据类型，还可以自定义创建数据类型。这就需要引入”类“这个概念。 什么是类？类，通俗一点讲就是模板，比如 student 类，就是学生的模板。Java 和 Python 定义类都是”class“这个关键字。12class Student(object): ##这就定义了一个类(模板) pass 用模板创建出来的对象叫做实例。xiaoming = Student()就创建一个 Student 类型的数据 xiaoming。xiaoming 是一个对象，也是 Student 类的一个实例。 类中定义了一组变量和方法，用该类实例化的对象，都会获得这些属性和方法。但是每一个实例都是独立的，也就是说，当一个实例的属性和方法发生变化时，不影响其他的实例。12345678class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 这是一个定义了 Student的完整的类，__init__方法是一个特殊的方法，从对象的角度，他为 Student能创建的实例都绑定了两个属性。所以说 Student 有 name 和 score 这两个属性，以及一个 print方法。从对象的生命周期上来讲，__init__方法对象实例化的入口，也就是说在执行bart = Student(&#39;Bart Simpson&#39;, 59)时，程序执行到___init__方法便创建了一个对象，并被分派给某些变量赋值。]]></content>
      <categories>
        <category>Learning Note</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
</search>
